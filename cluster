#!/bin/bash

# is an error handler needed? for usage?
#trap 'handle_error $LINENO' ERR

# A simple script to help with cluster management
#
#   cluster status        - what's the status of the cluster (default)
#   cluster up            - bring the entire cluster
#   cluster down          - bring the entire cluster down
#   cluster rebuild       - rebuild and start the cluster
#   cluster backup        - make a backup of the cluster
#   cluster restore <tgz> - restore a cluster from the given backup .tgz file

# TODO add better usage
# TODO migrate vackup functions to this one
# TODO refactor backup package.
# TODO better way to check status in the container. what are the expected services? parse the compose
# TODO check for tools: docker, yq

### sudo snap install yq <-- INSTALL YQ via snap 

name=$(basename "$0")

# get the context from parent dir
# NOTE:glossary - "context" is the namespace derived from the parent directory that compose uses in the docker engine.
cluster_dir="$(cd -P -- "$(dirname -- "$0")" && pwd -P)"
context=$(basename "$cluster_dir")

# WARNING: Right now, cluster assumes PWD is in the same t
composefile="docker-compose.yml"

# NOTE: remembering to type sudo gets me often.
DOCKER="sudo docker"

##
## Backup File Structure
##
# The backup file is created by: 'cluster backup'
# 1. Creating a new date-stamped dir from the parent-dir name (same as compose): name-YYYYMMDDHHMM
# 2. For each volume mentioned in the compose.yml
#   2.1 Run an empty container, with the volume and the backup dir mounted
#   2.2 Archive contents of volume: volume.tgz in the mounted backup dir, w/o parent-context
# 3. tar-gzip the entire backyp dir into name-YYYYMMDDHHMM.tgz
#
# Restoring the backup file with 'cluster restore backup-file.tgz'
# 1. Untar the backup file (into tmp?)
# 2. For each tgz file in the backup:
#   2.1 Confirm a matching entry in the compose file
#   2.2 ? Confirm a matching entry in container engine - note parent context of restore (ability to re-home)
#   2.3 Run a simple container, mounting the volume and the backup
#   2.4 Import the backup into the volume with tar on the specific volume
# 3. Cleanup the backup dir (leaving the backup.tgz untouched)


cmd_export() {
    VOLUME_NAME="$1"
    FILE_NAME="$2"

    if [ -z "$VOLUME_NAME" ] || [ -z "$FILE_NAME" ]; then
        echo "Error: Not enough arguments"
        usage
        exit 1
    fi
    
    if ! $DOCKER volume inspect --format '{{.Name}}' "$VOLUME_NAME";
    then
        echo "Error: Volume $VOLUME_NAME does not exist"
        exit 1
    fi

# TODO: if FILE_NAME starts with / we need to error out
# unless we can translate full file paths

# Added redirect to dev/null. remove to debug

    if ! $DOCKER run --rm \
      -v "$VOLUME_NAME":/backup-volume \
      -v "$(pwd)":/backup \
      busybox \
      tar -zcf /backup/"$FILE_NAME" /backup-volume > /dev/null 2>&1 ;
    then
        echo "Error: Failed to start busybox backup container"
        exit 1
    fi

    echo "exported $VOLUME_NAME into $FILE_NAME"
}

cmd_import() {
    FILE_NAME="$1"
    VOLUME_NAME="$2"
    
    if [ -z "$VOLUME_NAME" ] || [ -z "$FILE_NAME" ]; then
        echo "Error: Not enough arguments"
        usage
        exit 1
    fi
    
    if ! $DOCKER volume inspect --format '{{.Name}}' "$VOLUME_NAME";
    then
        echo "Error: Volume $VOLUME_NAME does not exist"
        $DOCKER volume create "$VOLUME_NAME"
    fi

# TODO: check if file exists on host, if it does
# create a option for overwrite and check if that's set
# TODO: if FILE_NAME starts with / we need to error out
# unless we can translate full file paths    

    if ! $DOCKER run --rm \
      -v "$VOLUME_NAME":/backup-volume \
      -v "$(pwd)":/backup \
      busybox \
      tar -xzf /backup/"$FILE_NAME" -C / > /dev/null 2>&1 ; 
    then
        echo "Error: Failed to start busybox container"
        exit 1
    fi
    echo "imported $VOLUME_NAME, from $FILE_NAME"
}

cmd_backup() {
    # generate a datestamp for YYYYmmHHMM; the current time to the minute
	datestr="$(date +%Y%m%H%M)"
	backupdir="$context-$datestr"
	mkdir -p "$backupdir"
	
	# parse the composefile to get the volume names
	yq e '.volumes | keys | .[]' $composefile | while read -r volume ; do
        # for each volume, export the volume to the
		volname="${context}_$volume"		
		target="$backupdir/$volume.tgz"
		cmd_export "$volname" "$target"
	done

    # finally, tar the tarfiles and remove the dir
    tarfile="$backupdir".tgz 
    tar -zcf "$tarfile" "$backupdir"
    rm -fr "$backupdir"
    echo backed-up "$context" to "$tarfile"
}

cmd_restore() {
	tarfile=$1

    # untar the tar file
    tar -xf "$tarfile"
    tardir=${tarfile%.*}

    # parse the composefile to get the volume names
	yq e '.volumes | keys | .[]' $composefile | while read -r volume ; do
        # for each volume, import the target into the volume
		volname="${context}_$volume"		
		target="$tardir/$volume.tgz"
        cmd_import "$target" "$volname"
	done

    # cleanup the untar directory.
    rm -fr "$tardir"
    echo "restored $context from $tarfile"
}

cmd_status() {
    $DOCKER ps 
}


# note: resolve $0 to get full path, and cd to it.

case "$1" in
    rebuild) $DOCKER compose down; $DOCKER --build -d ;;
    up)      $DOCKER compose up -d ;;
    down)    $DOCKER compose down ;;
    status)  cmd_status ;;
	backup)  cmd_backup ;;
	restore) cmd_restore "$2" ;;
    *)
        echo -e $"Usage: $name {up|down|status|rebuild|backup|restore <tgz>}"
        exit 1
esac
