#!/bin/bash

trap 'handle_error $LINENO' ERR

# A simple script to help with cluster management
#
#   cluster status        - what's the status of the cluster (default)
#   cluster up            - bring the entire cluster
#   cluster down          - bring the entire cluster down
#   cluster rebuild       - rebuild and start the cluster
#   cluster backup        - make a backup of the cluster
#   cluster restore <tgz> - restore a cluster from the given backup .tgz file

# TODO add better usage
# TODO migrate vackup functions to this one
# TODO refactor backup package.
# TODO better way to check status in the container. what are the expected services? parse the compose
# TODO check for tools: docker, yq

name=$(basename $0)
status=$1 # Just as a simple default

# WARNING: Right now, cluster assumes PWD is in the same t
composefile="docker-compose.yml"

# NOTE: remembering to type sudo gets me often.
DOCKER="sudo docker"

##
## Backup File Structure
##
# The backup file is created by: 'cluster backup'
# 1. Creating a new date-stamped dir from the parent-dir name (same as compose): name-YYYYMMDDHHMM
# 2. For each volume mentioned in the compose.yml
#   2.1 Run an empty container, with the volume and the backup dir mounted
#   2.2 Archive contents of volume: volume.tgz in the mounted backup dir, w/o parent-context
# 3. tar-gzip the entire backyp dir into name-YYYYMMDDHHMM.tgz
#
# Restoring the backup file with 'cluster restore backup-file.tgz'
# 1. Untar the backup file (into tmp?)
# 2. For each tgz file in the backup:
#   2.1 Confirm a matching entry in the compose file
#   2.2 ? Confirm a matching entry in container engine - note parent context of restore (ability to re-home)
#   2.3 Run a simple container, mounting the volume and the backup
#   2.4 Import the backup into the volume with tar on the specific volume
# 3. Cleanup the backup dir (leaving the backup.tgz untouched)


cmd_export() {
    VOLUME_NAME="$1"
    FILE_NAME="$2"

    if [ -z "$VOLUME_NAME" ] || [ -z "$FILE_NAME" ]; then
        echo "Error: Not enough arguments"
        usage
        exit 1
    fi
    
    if ! $DOCKER volume inspect --format '{{.Name}}' "$VOLUME_NAME";
    then
        echo "Error: Volume $VOLUME_NAME does not exist"
        exit 1
    fi

# TODO: if FILE_NAME starts with / we need to error out
# unless we can translate full file paths

# Added redirect to dev/null. remove to debug

    if ! $DOCKER run --rm \
      -v "$VOLUME_NAME":/backup-volume \
      -v "$(pwd)":/backup \
      busybox \
      tar -zcf /backup/"$FILE_NAME" /backup-volume ;
    then
        echo "Error: Failed to start busybox backup container"
        exit 1
    fi

    echo exported $VOLUME_NAME into $FILE_NAME"
}

cmd_import() {
    FILE_NAME="$1"
    VOLUME_NAME="$2"
    
    if [ -z "$VOLUME_NAME" ] || [ -z "$FILE_NAME" ]; then
        echo "Error: Not enough arguments"
        usage
        exit 1
    fi
    
    if ! $DOCKER volume inspect --format '{{.Name}}' "$VOLUME_NAME";
    then
        echo "Error: Volume $VOLUME_NAME does not exist"
        $DOCKER volume create "$VOLUME_NAME"
    fi

# TODO: check if file exists on host, if it does
# create a option for overwrite and check if that's set
# TODO: if FILE_NAME starts with / we need to error out
# unless we can translate full file paths    

    if ! $DOCKER run --rm \
      -v "$VOLUME_NAME":/backup-volume \
      -v "$(pwd)":/backup \
      busybox \
      tar -xvzf /backup/"$FILE_NAME" -C /; 
    then
        echo "Error: Failed to start busybox container"
        exit 1
    fi
    echo imported $VOLUME_NAME, from $FILE_NAME
}

cmd_backup() {
	# get the context from parent dir
	# NOTE:glossary - "context" is the namespace derived from the parent directory that compose uses in the docker engine.
	dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )";
	context="$(basename $dir)"
	#echo context=$context
	
	datestr="$(date +%Y%m%H%M)"
	backupdir="$context-$datestr"
	mkdir -p $backupdir
	
	# parse the composefile to get the volume names
	yq e '.volumes | keys | .[]' $composefile | while read volume ; do
		volname="${context}_${volume}"		
		target="${backupdir}/${volume}.tgz"
		cmd_export $volname $target
	done

    # finally, tar the tarfiles and remove the dir
    tar -zcvf "$backupdir".tgz $backupdir
    rm -fr $backupdir
}

cmd_restore() {
	tarfile=$1
    dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )";
	context="$(basename $dir)"

    # untar the tar to a new TMP_DIR
    #TMP_DIR=`mktemp -d` && tar -C $TMP_DIR -xf $tarfile
    tar -xf $tarfile
    tardir=${tarfile%.*}
    #echo Restored backup to tmp: $TMP_DIR/$tarname

    # parse the composefile to get the volume names
	yq e '.volumes | keys | .[]' $composefile | while read volume ; do
		volname="${context}_$volume"		
		target="$tardir/$volume.tgz"
        cmd_import $target $volname
        #echo restored $volname, from $tarfile
	done
    rm -fr $tardir
    echo restored $context from $tarfile
}

# note: resolve $0 to get full path, and cd to it.

case "$1" in
    rebuild) $DOCKER compose down; $DOCKER --build -d ;;
    up)      $DOCKER compose up -d ;;
    down)    $DOCKER compose down ;;
    status)  $DOCKER ps ;;
	backup)  cmd_backup ;;
	restore) cmd_restore "$2" ;;
    *)
        echo -e $"Usage: $name {up|down|status|rebuild|backup|restore <tgz>}"
        exit 1
esac
